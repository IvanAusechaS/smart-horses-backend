\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}

\geometry{margin=1in}

% Configuración de encabezado
\pagestyle{fancy}
\fancyhf{}
\rhead{Smart Horses - Informe de Heurística}
\lhead{Universidad del Valle}
\rfoot{Página \thepage}

% Configuración de hipervínculos
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Informe de Heurística - Smart Horses},
    pdfauthor={Andrey Quiceno, Ivan Ausecha, Jonathan Aristizabal, Jose Martínez},
}

% Configuración de código
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    backgroundcolor=\color{gray!10},
}

\title{
    \vspace{-1cm}
    \Huge\textbf{Informe de Heurística} \\
    \Large Smart Horses - Juego de Caballos Inteligentes \\
    \vspace{0.5cm}
    \large Algoritmo Minimax con Poda Alpha-Beta
}

\author{
    Andrey Quiceno \and
    Ivan Ausecha \and
    Jonathan Aristizabal \and
    Jose Martínez \\
    \\
    \textit{Universidad del Valle} \\
    \textit{Facultad de Ingeniería} \\
    \textit{Asignatura: Inteligencia Artificial}
}

\date{\today}

\begin{document}

\maketitle
\thispagestretch

\begin{abstract}
Este documento presenta la función heurística implementada para el juego Smart Horses, un juego estratégico de dos jugadores donde caballos (knights) compiten por puntos en un tablero de ajedrez. La heurística guía las decisiones del algoritmo Minimax con poda Alpha-Beta, evaluando posiciones del tablero considerando múltiples factores estratégicos. Se detallan la fórmula matemática, los pesos asignados, la justificación de diseño y el análisis de complejidad.
\end{abstract}

\section*{Enlaces del Proyecto}
\begin{itemize}
    \item \textbf{Repositorio Backend:} \url{https://github.com/IvanAusechaS/smart-horses-backend}
    \item \textbf{Repositorio Frontend:} \url{https://github.com/IvanAusechaS/smart-horses-frontend}
    \item \textbf{Despliegue:} TODO: Agregar URL de despliegue provisional
\end{itemize}

\tableofcontents
\newpage

\section{Introducción}

Smart Horses es un juego estratégico de suma cero para dos jugadores donde cada jugador controla un caballo de ajedrez en un tablero 8×8. El objetivo es acumular la mayor cantidad de puntos moviéndose a casillas especiales, mientras se evita quedar atrapado sin movimientos legales.

\subsection{Reglas del Juego}

\begin{itemize}
    \item \textbf{Tablero:} 8×8 con exactamente 10 casillas especiales con valores de puntos
    \item \textbf{Valores de puntos:} -10, -5, -4, -3, -1, +1, +3, +4, +5, +10 (uno de cada)
    \item \textbf{Movimientos:} Patrón L del caballo de ajedrez (8 direcciones posibles)
    \item \textbf{Destrucción:} Las casillas visitadas se destruyen y no pueden volver a usarse
    \item \textbf{Penalización:} -4 puntos si un jugador no tiene movimientos legales
    \item \textbf{Victoria:} El jugador con mayor puntuación cuando ambos quedan sin movimientos
\end{itemize}

\section{Función Heurística}

\subsection{Fórmula Matemática}

La función heurística $H(s)$ evalúa qué tan favorable es el estado $s$ para el jugador máximo (blanco/máquina). La fórmula completa es:

\begin{equation}
H(s) = w_1 \cdot \Delta_{\text{score}} + w_2 \cdot \Delta_{\text{mobility}} + w_3 \cdot \Delta_{\text{proximity}} + w_4 \cdot \Delta_{\text{center}} + w_5 \cdot N_{\text{trapped}}
\end{equation}

Donde cada componente se define como:

\begin{align}
\Delta_{\text{score}} &= S_w - S_b \\
\Delta_{\text{mobility}} &= M_w - M_b \\
\Delta_{\text{proximity}} &= P_w - P_b \\
\Delta_{\text{center}} &= C_w - C_b \\
N_{\text{trapped}} &= -400 \cdot I(M_w = 0) + 400 \cdot I(M_b = 0)
\end{align}

\subsection{Variables}

\begin{itemize}
    \item $S_w, S_b$: Puntuaciones actuales de blanco y negro
    \item $M_w, M_b$: Número de movimientos legales disponibles
    \item $P_w, P_b$: Valores de proximidad a casillas valiosas
    \item $C_w, C_b$: Indicadores de control del centro (1 si está en centro, 0 si no)
    \item $I(\cdot)$: Función indicadora (1 si verdadero, 0 si falso)
\end{itemize}

\subsection{Cálculo de Proximidad}

La proximidad se calcula como:

\begin{equation}
P_i = \sum_{v \in V} \frac{\text{valor}(v)}{\text{distancia}(K_i, v)}
\end{equation}

Donde:
\begin{itemize}
    \item $V$: Conjunto de casillas con puntos positivos no destruidas
    \item $K_i$: Posición del caballo del jugador $i$
    \item $\text{distancia}$: Distancia de Manhattan entre posiciones
    \item Si el caballo está en la casilla: $\text{valor}(v) \times 2$
\end{itemize}

\subsection{Prevención de Colisiones}

La heurística incluye lógica para prevenir que ambos caballos ocupen la misma casilla:
\begin{itemize}
    \item Los movimientos legales excluyen la posición actual del oponente
    \item El cálculo de movilidad considera esta restricción
    \item Esto garantiza que solo un caballo puede ocupar cada casilla en todo momento
\end{itemize}

\subsection{Pesos Asignados}

Los pesos fueron seleccionados para reflejar la importancia relativa de cada factor:

\begin{table}[h]
\centering
\begin{tabular}{|l|r|p{8cm}|}
\hline
\textbf{Factor} & \textbf{Peso} & \textbf{Justificación} \\
\hline
Diferencia de puntos & $w_1 = 100$ & Factor más importante. La victoria depende directamente de la puntuación final. \\
\hline
Movilidad & $w_2 = 10$ & Tener más movimientos ofrece flexibilidad estratégica y evita trampas. \\
\hline
Proximidad & $w_3 = 5$ & Estar cerca de casillas valiosas facilita su captura futura. \\
\hline
Control del centro & $w_4 = 3$ & Las posiciones centrales (3,3), (3,4), (4,3), (4,4) ofrecen mejor movilidad. \\
\hline
Penalización por trampa & $w_5 = -400$ & Penalización severa (-4 puntos × 100) para evitar quedarse sin movimientos. \\
\hline
\end{tabular}
\caption{Pesos de la función heurística y su justificación}
\end{table}

\subsection{Justificación de Diseño}

La jerarquía de pesos $w_1 \gg w_2 > w_3 > w_4 > |w_5|$ refleja la estrategia de juego:

\begin{enumerate}
    \item \textbf{Puntos primero ($w_1 = 100$):} El objetivo final es maximizar puntos. Este peso domina la evaluación.
    
    \item \textbf{Movilidad estratégica ($w_2 = 10$):} Mantener opciones de movimiento es crucial para:
    \begin{itemize}
        \item Evitar quedar atrapado (-4 puntos)
        \item Tener flexibilidad para responder al oponente
        \item Acceder a casillas valiosas futuras
    \end{itemize}
    
    \item \textbf{Posicionamiento táctico ($w_3 = 5$):} Estar cerca de casillas positivas prepara capturas futuras sin comprometer la posición actual.
    
    \item \textbf{Ventaja posicional ($w_4 = 3$):} El centro ofrece hasta 8 movimientos posibles vs. 2-4 en esquinas/bordes.
    
    \item \textbf{Evitar trampas ($w_5 = -400$):} La penalización es equivalente a perder 4 puntos, que es significativa en un juego donde el margen de victoria puede ser pequeño.
\end{enumerate}

\section{Estados Terminales}

Para estados de fin de juego, la heurística devuelve valores absolutos:

\begin{equation}
H_{\text{terminal}}(s) = \begin{cases}
    +10000 & \text{si blanco gana} \\
    -10000 & \text{si negro gana} \\
    0 & \text{si empate}
\end{cases}
\end{equation}

Estos valores garantizan que el Minimax siempre prefiera victorias sobre posiciones ventajosas no terminales.

\section{Ejemplo de Cálculo}

Consideremos una posición de medio juego:

\begin{itemize}
    \item Puntuación blanca: 15, Puntuación negra: 8
    \item Movimientos blancos: 6, Movimientos negros: 4
    \item Proximidad blanca: 10, Proximidad negra: 7
    \item Blanco en centro: Sí (1), Negro en centro: No (0)
    \item Ningún jugador atrapado
\end{itemize}

Aplicando la fórmula:

\begin{align*}
H(s) &= 100(15-8) + 10(6-4) + 5(10-7) + 3(1-0) + 0 \\
     &= 100(7) + 10(2) + 5(3) + 3(1) \\
     &= 700 + 20 + 15 + 3 \\
     &= 738
\end{align*}

\textbf{Interpretación:} Valor positivo alto ($> 500$) indica ventaja fuerte para blanco (máquina). Los puntos dominan la evaluación (700/738 = 95\%), con contribuciones menores de movilidad, proximidad y centro.

\section{Análisis de Complejidad}

\subsection{Complejidad Temporal}

\begin{equation}
T(s) = O(n + m)
\end{equation}

Donde:
\begin{itemize}
    \item $n$: Número de casillas valiosas ($n \leq 10$)
    \item $m$: Número de movimientos legales por caballo ($m \leq 8$)
\end{itemize}

\textbf{Desglose:}
\begin{itemize}
    \item Cálculo de diferencia de puntos: $O(1)$
    \item Contar movimientos legales: $O(m) = O(8) = O(1)$
    \item Calcular proximidad: $O(n) = O(10) = O(1)$
    \item Verificar control del centro: $O(1)$
    \item Verificar trampas: $O(1)$
\end{itemize}

\textbf{Total:} $O(1)$ en la práctica, ya que $n$ y $m$ están acotados por constantes pequeñas.

\subsection{Complejidad Espacial}

\begin{equation}
S(s) = O(1)
\end{equation}

La función heurística utiliza espacio constante: solo almacena acumuladores numéricos para cada componente de la evaluación.

\section{Integración con Minimax}

La heurística se invoca en las hojas del árbol Minimax (profundidad = 0) y en estados terminales. El algoritmo Minimax con poda Alpha-Beta tiene complejidad:

\begin{itemize}
    \item \textbf{Tiempo (sin poda):} $O(b^d)$ donde $b \approx 8$, $d \in \{2, 4, 6\}$
    \item \textbf{Tiempo (con poda):} $O(b^{d/2})$ en el mejor caso
    \item \textbf{Espacio:} $O(d)$ para la pila de recursión
\end{itemize}

Dado que $H(s) = O(1)$, no añade overhead significativo al Minimax.

\subsection{Rendimiento Medido}

Pruebas empíricas en tableros completos:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Dificultad} & \textbf{Profundidad} & \textbf{Nodos} & \textbf{Tiempo (ms)} & \textbf{Eficiencia Poda} \\
\hline
Principiante & 2 & 20-50 & $< 10$ & $\sim$40\% \\
Amateur & 4 & 200-500 & 10-50 & $\sim$60\% \\
Experto & 6 & 2,000-5,000 & 50-200 & $\sim$70\% \\
\hline
\end{tabular}
\caption{Rendimiento del Minimax por nivel de dificultad}
\end{table}

\section{Características Especiales}

\subsection{Prevención de Colisiones de Caballos}

Implementación actualizada (Noviembre 2025) que previene que ambos caballos ocupen la misma casilla:

\textbf{Archivos modificados:}
\begin{itemize}
    \item \texttt{smart\_backend/core/move\_generator.py}: Funciones \texttt{get\_valid\_moves()} y \texttt{count\_valid\_moves()} ahora aceptan \texttt{opponent\_position} como parámetro
    \item \texttt{smart\_backend/core/game\_state.py}: \texttt{get\_valid\_moves()} ahora pasa la posición del oponente
    \item \texttt{smart\_backend/algorithms/heuristic.py}: Cálculos de movilidad actualizados para considerar posición del oponente
\end{itemize}

\textbf{Lógica implementada:}
\begin{lstlisting}[language=Python, caption=Prevención de colisiones en move\_generator.py]
def get_valid_moves(position, board, opponent_position=None):
    valid_moves = []
    for move in knight_moves:
        new_pos = (position[0] + move[0], position[1] + move[1])
        # Validar que no sea la posicion del oponente
        if opponent_position and new_pos == opponent_position:
            continue
        # ... resto de validaciones
\end{lstlisting}

Esta mejora garantiza que el juego respeta la regla fundamental de que dos piezas no pueden ocupar el mismo espacio.

\section{Limitaciones y Consideraciones}

\subsection{Limitaciones}

\begin{enumerate}
    \item \textbf{Horizonte de búsqueda:} La profundidad máxima (6) puede no capturar todas las consecuencias a largo plazo.
    
    \item \textbf{Heurística imperfecta:} No considera:
    \begin{itemize}
        \item Patrones tácticos específicos (forks, pins)
        \item Secuencias forzadas de movimientos
        \item Probabilidad de que el oponente cometa errores
    \end{itemize}
    
    \item \textbf{Pesos estáticos:} Los mismos pesos se usan en apertura, medio juego y final, aunque la importancia relativa de los factores puede cambiar.
    
    \item \textbf{Distancia Manhattan:} No refleja la distancia real de movimiento del caballo (que sigue un patrón L).
\end{enumerate}

\subsection{Posibles Mejoras}

\begin{itemize}
    \item \textbf{Profundización iterativa:} Aumentar profundidad si el tiempo lo permite.
    \item \textbf{Ordenamiento de movimientos:} Evaluar movimientos prometedores primero para mejor poda.
    \item \textbf{Tablas de transposición:} Cachear evaluaciones de posiciones repetidas.
    \item \textbf{Pesos adaptativos:} Ajustar $w_i$ según la fase del juego.
    \item \textbf{Distancia real:} Usar búsqueda BFS para calcular movimientos mínimos del caballo.
\end{itemize}

\section{Conclusión}

La función heurística implementada proporciona una evaluación robusta y eficiente de posiciones en Smart Horses. La jerarquía de pesos prioriza correctamente los objetivos del juego: maximizar puntos, mantener movilidad y posicionarse estratégicamente.

Los resultados de pruebas muestran que la heurística, combinada con Minimax y poda Alpha-Beta, produce un oponente competente que:
\begin{itemize}
    \item Toma decisiones en tiempo real ($< 200$ ms incluso en modo experto)
    \item Juega de manera coherente con los principios estratégicos
    \item Ofrece desafío apropiado en cada nivel de dificultad
\end{itemize}

La documentación exhaustiva del código y los 28 tests automatizados garantizan la calidad y mantenibilidad de la implementación.

\section*{Referencias}

\begin{itemize}
    \item Russell, S., \& Norvig, P. (2020). \textit{Artificial Intelligence: A Modern Approach} (4th ed.). Pearson.
    \item Knuth, D. E., \& Moore, R. W. (1975). An Analysis of Alpha-Beta Pruning. \textit{Artificial Intelligence}, 6(4), 293-326.
    \item Documentación del código fuente: \texttt{smart\_backend/algorithms/}
\end{itemize}

\appendix

\section{Código de la Función Heurística}

\begin{lstlisting}[language=Python, caption=Implementación de evaluate\_game\_state]
def evaluate_game_state(game_state) -> float:
    """Evaluate how favorable the game state is for white."""
    # Terminal state
    if game_state.game_over:
        if game_state.winner == 'white':
            return 10000
        elif game_state.winner == 'black':
            return -10000
        else:
            return 0
    
    evaluation = 0.0
    
    # 1. Score Difference (weight: 100)
    score_diff = game_state.white_score - game_state.black_score
    evaluation += score_diff * 100
    
    # 2. Mobility (weight: 10) - Updated to prevent collisions
    white_moves = count_valid_moves(
        game_state.white_knight, game_state.board, game_state.black_knight
    )
    black_moves = count_valid_moves(
        game_state.black_knight, game_state.board, game_state.white_knight
    )
    mobility_diff = white_moves - black_moves
    evaluation += mobility_diff * 10
        else:
            return 0
    
    evaluation = 0.0
    
    # 1. Score Difference (weight: 100)
    score_diff = game_state.white_score - game_state.black_score
    evaluation += score_diff * 100
    
    # 2. Mobility (weight: 10)
    white_moves = count_valid_moves(
        game_state.white_knight, game_state.board)
    black_moves = count_valid_moves(
        game_state.black_knight, game_state.board)
    mobility_diff = white_moves - black_moves
    evaluation += mobility_diff * 10
    
    # 3. Proximity to valuable squares (weight: 5)
    valuable_squares = get_valuable_squares(game_state.board)
    if valuable_squares:
        white_proximity = 0
        black_proximity = 0
        
        for position, value in valuable_squares:
            white_dist = manhattan_distance(
                game_state.white_knight, position)
            black_dist = manhattan_distance(
                game_state.black_knight, position)
            
            if white_dist > 0:
                white_proximity += value / white_dist
            else:
                white_proximity += value * 2
            
            if black_dist > 0:
                black_proximity += value / black_dist
            else:
                black_proximity += value * 2
        
        evaluation += (white_proximity - black_proximity) * 5
    
    # 4. Center Control (weight: 3)
    if is_center_position(game_state.white_knight):
        evaluation += 3
    if is_center_position(game_state.black_knight):
        evaluation -= 3
    
    # 5. No-moves penalty (weight: -400)
    if white_moves == 0:
        evaluation -= 400
    if black_moves == 0:
        evaluation += 400
    
    return evaluation
\end{lstlisting}

\end{document}
